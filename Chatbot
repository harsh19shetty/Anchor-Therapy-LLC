{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "import numpy as np\n",
    "import unicodedata\n",
    "import re\n",
    "import pandas as pd\n",
    "import tensorflow.keras \n",
    "from tensorflow.keras.models import Model\n",
    "from tensorflow.keras.layers import Input, LSTM, Dense, Embedding\n",
    "from tensorflow.keras.utils import to_categorical\n",
    "from sklearn.utils import shuffle "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "conv = pd.read_csv(\"C:/Users/dell/Desktop/Practicum/Chatbot.csv\",encoding= 'unicode_escape')\n",
    "conv.head()\n",
    "conv=shuffle(conv)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "conv['Questions'] = conv['Questions'].astype(str)\n",
    "conv['Answers'] = conv['Answers'].astype(str)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# clean up text\n",
    "\n",
    "def unicode_to_ascii(s):\n",
    "    return ''.join(\n",
    "        c for c in unicodedata.normalize('NFD', s)\n",
    "        if unicodedata.category(c) != 'Mn'\n",
    "    )\n",
    "\n",
    "def normalize_string(s):\n",
    "    s = unicode_to_ascii(s)\n",
    "    s = re.sub(r'([!.?])', r' \\1', s)\n",
    "    s = re.sub(r'[^a-zA-Z.!?]+', r' ', s)\n",
    "    s = re.sub(r'\\s+', r' ', s)\n",
    "    return s"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# clean up text\n",
    "raw_data_en = [normalize_string(data) for data in conv[\"Questions\"]]\n",
    "\n",
    "# add special token <start>/<end> to indicate the beginning and end of a sentence\n",
    "raw_data_fr_in = ['<start> ' + normalize_string(data) for data in conv[\"Answers\"]]\n",
    "raw_data_fr_out = [normalize_string(data) + ' <end>' for data in conv[\"Answers\"]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total number of English words:  686\n"
     ]
    }
   ],
   "source": [
    "# Tokenize each sentence and index each word\n",
    "max_en_words = 5000\n",
    "max_en_len = 10\n",
    "en_tokenizer = tensorflow.keras.preprocessing.text.Tokenizer(filters='', \\\n",
    "                                                  num_words=max_en_words )\n",
    "en_tokenizer.fit_on_texts(raw_data_en)\n",
    "en_tokenizer.fit_on_texts(raw_data_fr_in)\n",
    "en_tokenizer.fit_on_texts(raw_data_fr_out)\n",
    "\n",
    "print(\"Total number of English words: \", len(en_tokenizer.word_index))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "data_q = en_tokenizer.texts_to_sequences(raw_data_en)\n",
    "data_q = tensorflow.keras.preprocessing.sequence.pad_sequences(data_q,\\\n",
    "                                                     maxlen=max_en_len, \\\n",
    "                                                     padding='post')\n",
    "\n",
    "data_a_in = en_tokenizer.texts_to_sequences(raw_data_fr_in)\n",
    "data_a_in = tensorflow.keras.preprocessing.sequence.pad_sequences(data_a_in,\\\n",
    "                                                     maxlen=max_en_len, \\\n",
    "                                                     padding='post')\n",
    "\n",
    "data_a_out = en_tokenizer.texts_to_sequences(raw_data_fr_out)\n",
    "data_a_out = tensorflow.keras.preprocessing.sequence.pad_sequences(data_a_out,\\\n",
    "                                                     maxlen=max_en_len, \\\n",
    "                                                     padding='post')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(51, 10, 5000)"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Convert each word index using one-hot coding\n",
    "# This variable is the target of training\n",
    "\n",
    "data_a_out_cat = to_categorical(data_a_out, num_classes=max_en_words)\n",
    "data_a_out_cat.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "latent_dim = 100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define an input sequence and process it.\n",
    "encoder_inputs = Input(shape=(max_en_len,))\n",
    "\n",
    "embed = Embedding(max_en_words, latent_dim, mask_zero = True, input_length=max_en_len)\n",
    "encoder_embed = embed(encoder_inputs)\n",
    "\n",
    "encoder_lstm = LSTM(latent_dim,return_state=True,\\\n",
    "                   dropout=0.2, recurrent_dropout=0.2)\n",
    "encoder_outputs, state_h, state_c = encoder_lstm(encoder_embed)\n",
    "encoder_states = [state_h, state_c]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set up the decoder, using `encoder_states` as initial state.\n",
    "# the shape of decoder_inputs is set to None so it can translate \n",
    "# with a single word input, not necessary a sentence input\n",
    "decoder_inputs = Input(shape=(None,))\n",
    "\n",
    "decoder_embed = embed(decoder_inputs)\n",
    "\n",
    "decoder_lstm = LSTM(latent_dim, return_sequences=True, return_state=True,\\\n",
    "                   dropout=0.2, recurrent_dropout=0.2)\n",
    "decoder_outputs, _, _ = decoder_lstm(decoder_embed, initial_state=encoder_states)\n",
    "decoder_dense = Dense(max_en_words, activation='softmax')\n",
    "decoder_outputs = decoder_dense(decoder_outputs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model: \"functional_1\"\n",
      "__________________________________________________________________________________________________\n",
      "Layer (type)                    Output Shape         Param #     Connected to                     \n",
      "==================================================================================================\n",
      "input_2 (InputLayer)            [(None, None)]       0                                            \n",
      "__________________________________________________________________________________________________\n",
      "input_1 (InputLayer)            [(None, 10)]         0                                            \n",
      "__________________________________________________________________________________________________\n",
      "embedding (Embedding)           multiple             500000      input_1[0][0]                    \n",
      "                                                                 input_2[0][0]                    \n",
      "__________________________________________________________________________________________________\n",
      "lstm (LSTM)                     [(None, 100), (None, 80400       embedding[0][0]                  \n",
      "__________________________________________________________________________________________________\n",
      "lstm_1 (LSTM)                   [(None, None, 100),  80400       embedding[1][0]                  \n",
      "                                                                 lstm[0][1]                       \n",
      "                                                                 lstm[0][2]                       \n",
      "__________________________________________________________________________________________________\n",
      "dense (Dense)                   (None, None, 5000)   505000      lstm_1[0][0]                     \n",
      "==================================================================================================\n",
      "Total params: 1,165,800\n",
      "Trainable params: 1,165,800\n",
      "Non-trainable params: 0\n",
      "__________________________________________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "# Define the model that will turn\n",
    "# `encoder_input_data` & `decoder_input_data` into `decoder_target_data`\n",
    "model = Model([encoder_inputs, decoder_inputs], decoder_outputs)\n",
    "\n",
    "model.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/50\n",
      "8/8 - 2s - loss: 8.1057 - categorical_accuracy: 0.0992 - val_loss: 7.9944 - val_categorical_accuracy: 0.1000\n",
      "Epoch 2/50\n",
      "8/8 - 1s - loss: 6.4610 - categorical_accuracy: 0.1044 - val_loss: 6.5702 - val_categorical_accuracy: 0.1000\n",
      "Epoch 3/50\n",
      "8/8 - 1s - loss: 5.1198 - categorical_accuracy: 0.1044 - val_loss: 6.5169 - val_categorical_accuracy: 0.1000\n",
      "Epoch 4/50\n",
      "8/8 - 1s - loss: 4.7719 - categorical_accuracy: 0.1044 - val_loss: 6.6000 - val_categorical_accuracy: 0.0818\n",
      "Epoch 5/50\n",
      "8/8 - 1s - loss: 4.6054 - categorical_accuracy: 0.1070 - val_loss: 6.7044 - val_categorical_accuracy: 0.0818\n",
      "Epoch 6/50\n",
      "8/8 - 1s - loss: 4.5083 - categorical_accuracy: 0.1018 - val_loss: 6.8024 - val_categorical_accuracy: 0.0818\n",
      "Epoch 7/50\n",
      "8/8 - 1s - loss: 4.4385 - categorical_accuracy: 0.1149 - val_loss: 6.9098 - val_categorical_accuracy: 0.0818\n",
      "Epoch 8/50\n",
      "8/8 - 1s - loss: 4.3889 - categorical_accuracy: 0.1097 - val_loss: 7.0325 - val_categorical_accuracy: 0.1000\n",
      "Epoch 9/50\n",
      "8/8 - 1s - loss: 4.3516 - categorical_accuracy: 0.1201 - val_loss: 7.1135 - val_categorical_accuracy: 0.1000\n",
      "Epoch 10/50\n",
      "8/8 - 1s - loss: 4.3074 - categorical_accuracy: 0.1175 - val_loss: 7.2075 - val_categorical_accuracy: 0.1182\n",
      "Epoch 11/50\n",
      "8/8 - 1s - loss: 4.2714 - categorical_accuracy: 0.1201 - val_loss: 7.2607 - val_categorical_accuracy: 0.1273\n",
      "Epoch 12/50\n",
      "8/8 - 1s - loss: 4.2393 - categorical_accuracy: 0.1227 - val_loss: 7.3398 - val_categorical_accuracy: 0.1273\n",
      "Epoch 13/50\n",
      "8/8 - 1s - loss: 4.2069 - categorical_accuracy: 0.1332 - val_loss: 7.4367 - val_categorical_accuracy: 0.1091\n",
      "Epoch 14/50\n",
      "8/8 - 1s - loss: 4.1811 - categorical_accuracy: 0.1253 - val_loss: 7.4480 - val_categorical_accuracy: 0.1455\n",
      "Epoch 15/50\n",
      "8/8 - 1s - loss: 4.1424 - categorical_accuracy: 0.1462 - val_loss: 7.5541 - val_categorical_accuracy: 0.1091\n",
      "Epoch 16/50\n",
      "8/8 - 1s - loss: 4.3969 - categorical_accuracy: 0.1279 - val_loss: 7.5432 - val_categorical_accuracy: 0.1182\n",
      "Epoch 17/50\n",
      "8/8 - 1s - loss: 4.0895 - categorical_accuracy: 0.1332 - val_loss: 7.4584 - val_categorical_accuracy: 0.1455\n",
      "Epoch 18/50\n",
      "8/8 - 1s - loss: 4.0569 - categorical_accuracy: 0.1384 - val_loss: 7.3949 - val_categorical_accuracy: 0.1636\n",
      "Epoch 19/50\n",
      "8/8 - 1s - loss: 4.0210 - categorical_accuracy: 0.1540 - val_loss: 7.4758 - val_categorical_accuracy: 0.1273\n",
      "Epoch 20/50\n",
      "8/8 - 1s - loss: 3.9974 - categorical_accuracy: 0.1540 - val_loss: 7.4041 - val_categorical_accuracy: 0.1727\n",
      "Epoch 21/50\n",
      "8/8 - 1s - loss: 3.9607 - categorical_accuracy: 0.1540 - val_loss: 7.5094 - val_categorical_accuracy: 0.1636\n",
      "Epoch 22/50\n",
      "8/8 - 1s - loss: 3.9363 - categorical_accuracy: 0.1540 - val_loss: 7.4837 - val_categorical_accuracy: 0.1727\n",
      "Epoch 23/50\n",
      "8/8 - 1s - loss: 3.9078 - categorical_accuracy: 0.1619 - val_loss: 7.5310 - val_categorical_accuracy: 0.1727\n",
      "Epoch 24/50\n",
      "8/8 - 1s - loss: 3.8887 - categorical_accuracy: 0.1488 - val_loss: 7.4616 - val_categorical_accuracy: 0.1909\n",
      "Epoch 25/50\n",
      "8/8 - 1s - loss: 3.8579 - categorical_accuracy: 0.1775 - val_loss: 7.5867 - val_categorical_accuracy: 0.1818\n",
      "Epoch 26/50\n",
      "8/8 - 1s - loss: 3.8284 - categorical_accuracy: 0.1723 - val_loss: 7.6228 - val_categorical_accuracy: 0.1818\n",
      "Epoch 27/50\n",
      "8/8 - 1s - loss: 3.8042 - categorical_accuracy: 0.1828 - val_loss: 7.7403 - val_categorical_accuracy: 0.1818\n",
      "Epoch 28/50\n",
      "8/8 - 1s - loss: 3.7826 - categorical_accuracy: 0.1854 - val_loss: 7.6600 - val_categorical_accuracy: 0.1909\n",
      "Epoch 29/50\n",
      "8/8 - 1s - loss: 3.7539 - categorical_accuracy: 0.1880 - val_loss: 7.7827 - val_categorical_accuracy: 0.1909\n",
      "Epoch 30/50\n",
      "8/8 - 1s - loss: 3.7307 - categorical_accuracy: 0.2089 - val_loss: 7.7463 - val_categorical_accuracy: 0.1818\n",
      "Epoch 31/50\n",
      "8/8 - 1s - loss: 3.6997 - categorical_accuracy: 0.2089 - val_loss: 7.8384 - val_categorical_accuracy: 0.1818\n",
      "Epoch 32/50\n",
      "8/8 - 1s - loss: 3.6773 - categorical_accuracy: 0.2063 - val_loss: 7.8298 - val_categorical_accuracy: 0.1909\n",
      "Epoch 33/50\n",
      "8/8 - 1s - loss: 3.6475 - categorical_accuracy: 0.2245 - val_loss: 7.8422 - val_categorical_accuracy: 0.1818\n",
      "Epoch 34/50\n",
      "8/8 - 1s - loss: 3.6231 - categorical_accuracy: 0.2219 - val_loss: 7.8914 - val_categorical_accuracy: 0.1909\n",
      "Epoch 35/50\n",
      "8/8 - 1s - loss: 3.5894 - categorical_accuracy: 0.2219 - val_loss: 7.9166 - val_categorical_accuracy: 0.1818\n",
      "Epoch 36/50\n",
      "8/8 - 1s - loss: 3.5598 - categorical_accuracy: 0.2167 - val_loss: 7.9614 - val_categorical_accuracy: 0.1909\n",
      "Epoch 37/50\n",
      "8/8 - 1s - loss: 3.5315 - categorical_accuracy: 0.2193 - val_loss: 7.9965 - val_categorical_accuracy: 0.1909\n",
      "Epoch 38/50\n",
      "8/8 - 1s - loss: 3.5081 - categorical_accuracy: 0.2298 - val_loss: 7.9739 - val_categorical_accuracy: 0.1909\n",
      "Epoch 39/50\n",
      "8/8 - 1s - loss: 3.4780 - categorical_accuracy: 0.2219 - val_loss: 7.9975 - val_categorical_accuracy: 0.1909\n",
      "Epoch 40/50\n",
      "8/8 - 1s - loss: 3.4506 - categorical_accuracy: 0.2245 - val_loss: 8.0127 - val_categorical_accuracy: 0.1818\n",
      "Epoch 41/50\n",
      "8/8 - 1s - loss: 3.4232 - categorical_accuracy: 0.2272 - val_loss: 8.0029 - val_categorical_accuracy: 0.1818\n",
      "Epoch 42/50\n",
      "8/8 - 1s - loss: 3.3996 - categorical_accuracy: 0.2272 - val_loss: 8.0252 - val_categorical_accuracy: 0.1909\n",
      "Epoch 43/50\n",
      "8/8 - 1s - loss: 3.3689 - categorical_accuracy: 0.2298 - val_loss: 8.0520 - val_categorical_accuracy: 0.2000\n",
      "Epoch 44/50\n",
      "8/8 - 1s - loss: 3.3428 - categorical_accuracy: 0.2272 - val_loss: 8.0615 - val_categorical_accuracy: 0.1909\n",
      "Epoch 45/50\n",
      "8/8 - 1s - loss: 3.3141 - categorical_accuracy: 0.2324 - val_loss: 8.0571 - val_categorical_accuracy: 0.1818\n",
      "Epoch 46/50\n",
      "8/8 - 1s - loss: 3.2960 - categorical_accuracy: 0.2272 - val_loss: 8.0720 - val_categorical_accuracy: 0.1818\n",
      "Epoch 47/50\n",
      "8/8 - 1s - loss: 3.2555 - categorical_accuracy: 0.2324 - val_loss: 8.1111 - val_categorical_accuracy: 0.1818\n",
      "Epoch 48/50\n",
      "8/8 - 1s - loss: 3.2407 - categorical_accuracy: 0.2272 - val_loss: 8.0876 - val_categorical_accuracy: 0.1909\n",
      "Epoch 49/50\n",
      "8/8 - 1s - loss: 3.2167 - categorical_accuracy: 0.2298 - val_loss: 8.0839 - val_categorical_accuracy: 0.1909\n",
      "Epoch 50/50\n",
      "8/8 - 1s - loss: 3.1880 - categorical_accuracy: 0.2298 - val_loss: 8.1229 - val_categorical_accuracy: 0.1818\n"
     ]
    }
   ],
   "source": [
    "batch_size=5\n",
    "epochs = 50\n",
    "\n",
    "\n",
    "# Compile & run training\n",
    "model.compile(optimizer='rmsprop', \\\n",
    "              loss='categorical_crossentropy',\\\n",
    "              metrics=['categorical_accuracy'])\n",
    "\n",
    "history = model.fit([data_q, data_a_in],data_a_out_cat, batch_size=batch_size,\\\n",
    "                       verbose =2, epochs=epochs, \\\n",
    "                       validation_split=0.2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model: \"functional_3\"\n",
      "__________________________________________________________________________________________________\n",
      "Layer (type)                    Output Shape         Param #     Connected to                     \n",
      "==================================================================================================\n",
      "input_4 (InputLayer)            [(None, None)]       0                                            \n",
      "__________________________________________________________________________________________________\n",
      "input_3 (InputLayer)            [(None, 10)]         0                                            \n",
      "__________________________________________________________________________________________________\n",
      "embedding_1 (Embedding)         multiple             500000      input_3[0][0]                    \n",
      "                                                                 input_4[0][0]                    \n",
      "__________________________________________________________________________________________________\n",
      "bidirectional (Bidirectional)   [(None, 10, 200), (N 160800      embedding_1[0][0]                \n",
      "__________________________________________________________________________________________________\n",
      "concatenate (Concatenate)       (None, 200)          0           bidirectional[0][1]              \n",
      "                                                                 bidirectional[0][3]              \n",
      "__________________________________________________________________________________________________\n",
      "concatenate_1 (Concatenate)     (None, 200)          0           bidirectional[0][2]              \n",
      "                                                                 bidirectional[0][4]              \n",
      "__________________________________________________________________________________________________\n",
      "lstm_3 (LSTM)                   [(None, None, 200),  240800      embedding_1[1][0]                \n",
      "                                                                 concatenate[0][0]                \n",
      "                                                                 concatenate_1[0][0]              \n",
      "__________________________________________________________________________________________________\n",
      "dense_1 (Dense)                 (None, 10, 200)      40000       bidirectional[0][0]              \n",
      "__________________________________________________________________________________________________\n",
      "dot (Dot)                       (None, None, 10)     0           lstm_3[0][0]                     \n",
      "                                                                 dense_1[0][0]                    \n",
      "__________________________________________________________________________________________________\n",
      "activation (Activation)         (None, None, 10)     0           dot[0][0]                        \n",
      "__________________________________________________________________________________________________\n",
      "activation_1 (Activation)       (None, None, 10)     0           activation[0][0]                 \n",
      "__________________________________________________________________________________________________\n",
      "dot_1 (Dot)                     (None, None, 200)    0           activation_1[0][0]               \n",
      "                                                                 bidirectional[0][0]              \n",
      "__________________________________________________________________________________________________\n",
      "concatenate_2 (Concatenate)     (None, None, 400)    0           dot_1[0][0]                      \n",
      "                                                                 lstm_3[0][0]                     \n",
      "__________________________________________________________________________________________________\n",
      "dense_2 (Dense)                 (None, None, 5000)   2005000     concatenate_2[0][0]              \n",
      "==================================================================================================\n",
      "Total params: 2,946,600\n",
      "Trainable params: 2,946,600\n",
      "Non-trainable params: 0\n",
      "__________________________________________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "from tensorflow.keras.layers import Lambda, Dot, Activation, Concatenate, Dropout, Bidirectional\n",
    "from tensorflow.keras import backend as K\n",
    "\n",
    "max_en_words = 5000\n",
    "max_en_len = 10\n",
    "latent_dim = 100\n",
    "\n",
    "# Define an input sequence and process it.\n",
    "encoder_inputs = Input(shape=(max_en_len,))\n",
    "\n",
    "embed = Embedding(max_en_words, latent_dim, mask_zero = True, input_length=max_en_len)\n",
    "encoder_embed = embed(encoder_inputs)\n",
    "\n",
    "encoder_lstm = Bidirectional(LSTM(latent_dim,return_sequences=True, \\\n",
    "                    dropout = 0.2, recurrent_dropout =0.2,\\\n",
    "                    return_state=True))\n",
    "\n",
    "encoder_outputs, forward_h, forward_c, backward_h, backward_c = encoder_lstm(encoder_embed)\n",
    "\n",
    "state_h = Concatenate()([forward_h, backward_h])\n",
    "state_c = Concatenate()([forward_c, backward_c])\n",
    "\n",
    "encoder_states = [state_h, state_c]\n",
    "\n",
    "# Set up the decoder, using `encoder_states` as initial state.\n",
    "# the shape of decoder_inputs is set to None so it can translate \n",
    "# with a single word input, not necessary a sentence input\n",
    "decoder_inputs = Input(shape=(None,))\n",
    "\n",
    "decoder_embed = embed(decoder_inputs)\n",
    "\n",
    "decoder_lstm = LSTM(200, return_sequences=True, return_state=True, \\\n",
    "                   dropout = 0.2, recurrent_dropout =0.2)\n",
    "\n",
    "decoder_outputs, _, _ = decoder_lstm(decoder_embed, initial_state=encoder_states)\n",
    "\n",
    "\n",
    "# Transform encoder outputs to a space which can be aligned with decoder output\n",
    "encoder_outputs_transformed = Dense(200, \\\n",
    "                                    activation=None, \\\n",
    "                                    use_bias=False)(encoder_outputs)\n",
    "\n",
    "# Calculate alignment between decoder and encoder\n",
    "attention = Dot(axes = [2,2])([decoder_outputs, encoder_outputs_transformed])\n",
    "attention = Activation('tanh')(attention)\n",
    "\n",
    "\n",
    "# Normalize alignment score\n",
    "attention = Activation('softmax')(attention)\n",
    "\n",
    "# Weighted sum\n",
    "context = Dot(axes=[2,1]) ([attention, encoder_outputs])\n",
    "\n",
    "# Concatenate context with decoder output\n",
    "decoder_combined_context = Concatenate(axis = -1)([context, decoder_outputs])\n",
    "\n",
    "decoder_dense = Dense(max_en_words, activation='softmax')\n",
    "decoder_outputs = decoder_dense(decoder_combined_context)\n",
    "\n",
    "# Define the model that will turn\n",
    "# `encoder_input_data` & `decoder_input_data` into `decoder_target_data`\n",
    "model2 = Model([encoder_inputs, decoder_inputs], decoder_outputs)\n",
    "\n",
    "model2.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/50\n",
      "8/8 - 3s - loss: 7.9323 - categorical_accuracy: 0.1097 - val_loss: 6.8428 - val_categorical_accuracy: 0.0818\n",
      "Epoch 2/50\n",
      "8/8 - 1s - loss: 5.5693 - categorical_accuracy: 0.1097 - val_loss: 6.6699 - val_categorical_accuracy: 0.1091\n",
      "Epoch 3/50\n",
      "8/8 - 1s - loss: 4.7750 - categorical_accuracy: 0.1253 - val_loss: 6.9426 - val_categorical_accuracy: 0.0909\n",
      "Epoch 4/50\n",
      "8/8 - 1s - loss: 4.4669 - categorical_accuracy: 0.1305 - val_loss: 7.1856 - val_categorical_accuracy: 0.0909\n",
      "Epoch 5/50\n",
      "8/8 - 1s - loss: 4.3384 - categorical_accuracy: 0.1149 - val_loss: 7.4015 - val_categorical_accuracy: 0.1091\n",
      "Epoch 6/50\n",
      "8/8 - 1s - loss: 4.2323 - categorical_accuracy: 0.1305 - val_loss: 7.5099 - val_categorical_accuracy: 0.1364\n",
      "Epoch 7/50\n",
      "8/8 - 1s - loss: 4.1445 - categorical_accuracy: 0.1462 - val_loss: 7.7097 - val_categorical_accuracy: 0.1091\n",
      "Epoch 8/50\n",
      "8/8 - 1s - loss: 4.0677 - categorical_accuracy: 0.1593 - val_loss: 7.8102 - val_categorical_accuracy: 0.1273\n",
      "Epoch 9/50\n",
      "8/8 - 1s - loss: 4.0035 - categorical_accuracy: 0.1540 - val_loss: 8.0723 - val_categorical_accuracy: 0.1273\n",
      "Epoch 10/50\n",
      "8/8 - 1s - loss: 3.9254 - categorical_accuracy: 0.1619 - val_loss: 8.0843 - val_categorical_accuracy: 0.1364\n",
      "Epoch 11/50\n",
      "8/8 - 1s - loss: 3.8561 - categorical_accuracy: 0.1671 - val_loss: 8.2760 - val_categorical_accuracy: 0.1455\n",
      "Epoch 12/50\n",
      "8/8 - 1s - loss: 3.7817 - categorical_accuracy: 0.1697 - val_loss: 8.3296 - val_categorical_accuracy: 0.1636\n",
      "Epoch 13/50\n",
      "8/8 - 1s - loss: 3.7167 - categorical_accuracy: 0.1802 - val_loss: 8.4103 - val_categorical_accuracy: 0.1182\n",
      "Epoch 14/50\n",
      "8/8 - 1s - loss: 3.6585 - categorical_accuracy: 0.1802 - val_loss: 8.4733 - val_categorical_accuracy: 0.1364\n",
      "Epoch 15/50\n",
      "8/8 - 1s - loss: 3.5839 - categorical_accuracy: 0.1802 - val_loss: 8.5046 - val_categorical_accuracy: 0.1636\n",
      "Epoch 16/50\n",
      "8/8 - 1s - loss: 3.5309 - categorical_accuracy: 0.1906 - val_loss: 8.5197 - val_categorical_accuracy: 0.2091\n",
      "Epoch 17/50\n",
      "8/8 - 1s - loss: 3.4664 - categorical_accuracy: 0.2167 - val_loss: 8.5736 - val_categorical_accuracy: 0.1636\n",
      "Epoch 18/50\n",
      "8/8 - 1s - loss: 3.4135 - categorical_accuracy: 0.2115 - val_loss: 8.5806 - val_categorical_accuracy: 0.1636\n",
      "Epoch 19/50\n",
      "8/8 - 1s - loss: 3.3487 - categorical_accuracy: 0.2167 - val_loss: 8.6045 - val_categorical_accuracy: 0.2182\n",
      "Epoch 20/50\n",
      "8/8 - 1s - loss: 3.3126 - categorical_accuracy: 0.2298 - val_loss: 8.6103 - val_categorical_accuracy: 0.1909\n",
      "Epoch 21/50\n",
      "8/8 - 1s - loss: 3.2444 - categorical_accuracy: 0.2402 - val_loss: 8.6353 - val_categorical_accuracy: 0.1818\n",
      "Epoch 22/50\n",
      "8/8 - 1s - loss: 3.1913 - categorical_accuracy: 0.2350 - val_loss: 8.6492 - val_categorical_accuracy: 0.1727\n",
      "Epoch 23/50\n",
      "8/8 - 1s - loss: 3.1507 - categorical_accuracy: 0.2507 - val_loss: 8.6635 - val_categorical_accuracy: 0.1727\n",
      "Epoch 24/50\n",
      "8/8 - 1s - loss: 3.0910 - categorical_accuracy: 0.2480 - val_loss: 8.6790 - val_categorical_accuracy: 0.1727\n",
      "Epoch 25/50\n",
      "8/8 - 1s - loss: 3.0448 - categorical_accuracy: 0.2507 - val_loss: 8.7015 - val_categorical_accuracy: 0.2091\n",
      "Epoch 26/50\n",
      "8/8 - 1s - loss: 2.9842 - categorical_accuracy: 0.2585 - val_loss: 8.7265 - val_categorical_accuracy: 0.1818\n",
      "Epoch 27/50\n",
      "8/8 - 1s - loss: 2.9518 - categorical_accuracy: 0.2559 - val_loss: 8.7267 - val_categorical_accuracy: 0.1909\n",
      "Epoch 28/50\n",
      "8/8 - 1s - loss: 2.9016 - categorical_accuracy: 0.2559 - val_loss: 8.7387 - val_categorical_accuracy: 0.1909\n",
      "Epoch 29/50\n",
      "8/8 - 1s - loss: 2.8537 - categorical_accuracy: 0.2611 - val_loss: 8.7630 - val_categorical_accuracy: 0.1818\n",
      "Epoch 30/50\n",
      "8/8 - 1s - loss: 2.8035 - categorical_accuracy: 0.2663 - val_loss: 8.7742 - val_categorical_accuracy: 0.1909\n",
      "Epoch 31/50\n",
      "8/8 - 1s - loss: 2.7515 - categorical_accuracy: 0.2742 - val_loss: 8.7867 - val_categorical_accuracy: 0.1818\n",
      "Epoch 32/50\n",
      "8/8 - 1s - loss: 2.6917 - categorical_accuracy: 0.3003 - val_loss: 8.8075 - val_categorical_accuracy: 0.1818\n",
      "Epoch 33/50\n",
      "8/8 - 1s - loss: 2.6521 - categorical_accuracy: 0.2846 - val_loss: 8.8365 - val_categorical_accuracy: 0.1727\n",
      "Epoch 34/50\n",
      "8/8 - 1s - loss: 2.6060 - categorical_accuracy: 0.2977 - val_loss: 8.8604 - val_categorical_accuracy: 0.2000\n",
      "Epoch 35/50\n",
      "8/8 - 1s - loss: 2.5487 - categorical_accuracy: 0.3238 - val_loss: 8.8756 - val_categorical_accuracy: 0.1818\n",
      "Epoch 36/50\n",
      "8/8 - 1s - loss: 2.4962 - categorical_accuracy: 0.3264 - val_loss: 8.8783 - val_categorical_accuracy: 0.1818\n",
      "Epoch 37/50\n",
      "8/8 - 1s - loss: 2.4481 - categorical_accuracy: 0.3342 - val_loss: 8.9022 - val_categorical_accuracy: 0.1727\n",
      "Epoch 38/50\n",
      "8/8 - 1s - loss: 2.4114 - categorical_accuracy: 0.3446 - val_loss: 8.9204 - val_categorical_accuracy: 0.1909\n",
      "Epoch 39/50\n",
      "8/8 - 1s - loss: 2.3482 - categorical_accuracy: 0.3812 - val_loss: 8.9558 - val_categorical_accuracy: 0.1909\n",
      "Epoch 40/50\n",
      "8/8 - 1s - loss: 2.3051 - categorical_accuracy: 0.3995 - val_loss: 8.9618 - val_categorical_accuracy: 0.1727\n",
      "Epoch 41/50\n",
      "8/8 - 1s - loss: 2.2523 - categorical_accuracy: 0.3838 - val_loss: 8.9931 - val_categorical_accuracy: 0.1727\n",
      "Epoch 42/50\n",
      "8/8 - 1s - loss: 2.2093 - categorical_accuracy: 0.4204 - val_loss: 9.0308 - val_categorical_accuracy: 0.1545\n",
      "Epoch 43/50\n",
      "8/8 - 1s - loss: 2.1642 - categorical_accuracy: 0.4334 - val_loss: 9.0114 - val_categorical_accuracy: 0.1636\n",
      "Epoch 44/50\n",
      "8/8 - 1s - loss: 2.1069 - categorical_accuracy: 0.4413 - val_loss: 9.0502 - val_categorical_accuracy: 0.1727\n",
      "Epoch 45/50\n",
      "8/8 - 1s - loss: 2.0528 - categorical_accuracy: 0.4700 - val_loss: 9.0304 - val_categorical_accuracy: 0.1727\n",
      "Epoch 46/50\n",
      "8/8 - 1s - loss: 2.0186 - categorical_accuracy: 0.4674 - val_loss: 9.0817 - val_categorical_accuracy: 0.1818\n",
      "Epoch 47/50\n",
      "8/8 - 1s - loss: 1.9676 - categorical_accuracy: 0.4700 - val_loss: 9.1087 - val_categorical_accuracy: 0.1909\n",
      "Epoch 48/50\n",
      "8/8 - 1s - loss: 1.9239 - categorical_accuracy: 0.5013 - val_loss: 9.1182 - val_categorical_accuracy: 0.1545\n",
      "Epoch 49/50\n",
      "8/8 - 1s - loss: 1.8816 - categorical_accuracy: 0.5065 - val_loss: 9.1347 - val_categorical_accuracy: 0.1909\n",
      "Epoch 50/50\n",
      "8/8 - 1s - loss: 1.8236 - categorical_accuracy: 0.5352 - val_loss: 9.1431 - val_categorical_accuracy: 0.1909\n"
     ]
    }
   ],
   "source": [
    "# Compile & run training\n",
    "batch_size=5\n",
    "epochs = 50\n",
    "\n",
    "model2.compile(optimizer='rmsprop', \\\n",
    "              loss='categorical_crossentropy',\\\n",
    "              metrics=['categorical_accuracy'])\n",
    "\n",
    "history2 = model2.fit([data_q, data_a_in],data_a_out_cat, batch_size=batch_size,\\\n",
    "                       verbose =2, epochs=epochs, \\\n",
    "                       validation_split=0.2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Compare the result\n",
    "def smooth_curve(points, factor=0.8):\n",
    "    smoothed_points = []\n",
    "    for point in points:\n",
    "        if smoothed_points:\n",
    "            previous = smoothed_points[-1]\n",
    "            smoothed_points.append(previous * factor + point * (1 - factor))\n",
    "        else:\n",
    "            smoothed_points.append(point)\n",
    "    return smoothed_points\n",
    "\n",
    "epochs = range(1, len(history.history['val_categorical_accuracy']) + 1)\n",
    "plt.plot(epochs, smooth_curve(history.history['val_categorical_accuracy']), 'r-', label='Basic')\n",
    "plt.plot(epochs, smooth_curve(history2.history['val_categorical_accuracy']), 'b-', label='Attention')\n",
    "plt.title('Validation Accuracy')\n",
    "plt.xlabel('Epochs')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
